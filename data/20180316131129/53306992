<!DOCTYPE html>
<html>
  <head>
    <link rel="canonical" href="//blog.csdn.net/caoshangpa/article/details/53306992"/> 
    <script type="text/javascript">
        var username = "caoshangpa";
        var _blogger = username;
        var blog_address = "//blog.csdn.net/caoshangpa";
        var static_host = "https://csdnimg.cn/release/phoenix/";
        var currentUserName = ""; 
        var fileName = '53306992';
        var commentscount = 3;
        var islock = false;
        window.quickReplyflag = true;
        var totalFloor = 3;
        var isBole = false;
        var isDigg = false;
        var isExpert = false;
        var isAdm = false;
        var baiduKey = "";
        var needInsertBaidu = true;
        var isShowAds = true;
    </script>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="referrer" content="always">
    <script src="//csdnimg.cn/public/common/libs/jquery/jquery-1.9.1.min.js" type="text/javascript"></script>
    <link rel="stylesheet" href="//csdnimg.cn/public/static/css/avatar.css">
                <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/production/main-5abef24e21.css">
          <link rel="stylesheet" href="//csdnimg.cn/public/common/toolbar/content_toolbar_css/content_toolbar.css">

    <script src="//csdnimg.cn/rabbit/exposure-click/main-1.0.5.js"></script>
    <script type="text/javascript" src="//csdnimg.cn/pubfooter/js/tracking-1.0.2.js" charset="utf-8"></script>
    <script type="text/javascript" src="https://csdnimg.cn/release/phoenix/production/main-610dfc0998.js"></script>

    <script src="https://dup.baidustatic.com/js/ds.js"></script>
    <script type="text/javascript">
        // Traffic Stats of the entire Web site By baidu
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?6bcd52f51e9b3dce32bec4a3997715ac";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
        // Traffic Stats of the entire Web site By baidu end
    </script>
    <meta name="description" content="一.无插件的实时通讯
       想像一下，如果你的手机、电视、电脑都可以通过一个平台进行通信，想像一下，你可以在Web应用中轻松地加入视频聊天和p2p数据分享，这就是WebRTC的愿景。
       想试一试吗？WebRTC现在已经被集成到Chrome、Opera和Firefox，在apprtc.appspot.com有个简单的视频聊天应用可供测试。
1.在Chrome、Opera或F" />
    <meta name="keywords" content="WebRTC" />
    <meta http-equiv="Cache-Control" content="no-siteapp" /><link rel="alternate" media="handheld" href="#" />
    <meta name="shenma-site-verification" content="5a59773ab8077d4a62bf469ab966a63b_1497598848">
    <title>WebRTC学习之一：开篇 - CSDN博客</title>
    <link href="//csdnimg.cn/public/favicon.ico" rel="SHORTCUT ICON">
                      <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/production/htmledit_views-1f9cf0a071.css">
      </head>
<body>
<script id="toolbar-tpl-scriptId" prod="download" skin="black" src="//csdnimg.cn/public/common/toolbar/js/content_toolbar.js" type="text/javascript" domain="//blog.csdn.net/"></script>
<div class="container clearfix">
  <main>
    <div style="display:none;">
      <img src="" onerror='setTimeout(function(){if(!/(csdn.net|iteye.com|baiducontent.com|googleusercontent.com|360webcache.com|sogoucdn.com|bingj.com|baidu.com)$/.test(window.location.hostname)){window.location.href="\x68\x74\x74\x70\x73\x3a\x2f\x2f\x77\x77\x77\x2e\x63\x73\x64\x6e\x2e\x6e\x65\x74"}},3000);'>
    </div>
    <article>
        <h1 class="csdn_top">WebRTC学习之一：开篇</h1>
        <div class="article_bar clearfix">
            <div class="artical_tag">
                <span class="original">
                原创                </span>
                <span class="time">2016年11月23日 17:25:19</span>
            </div>

            <ul class="article_tags clearfix csdn-tracking-statistics tracking-click" data-mod="popu_377" >
                <li class="tit">标签：</li>

<!--          [startarticletags]-->
                                                            <li><a href="http://so.csdn.net/so/search/s.do?q=WebRTC&t=blog" target="_blank">WebRTC</a> <span>/</span></li>
                                    <!--          [endarticletags]-->
            </ul>
            <ul class="right_bar">
                <li><button class="btn-noborder"><i class="icon iconfont icon-read"></i><span class="txt">10027</span></button></li>
                <li class="edit">
                    <a class="btn-noborder" href="" >
                        <i class="icon iconfont icon-bianji"></i><span class="txt">编辑</span>
                    </a>
                </li>
                <li class="del">
                    <a class="btn-noborder" onclick="javascript:deleteArticle(fileName);return false;">
                        <i class="icon iconfont icon-shanchu"></i><span class="txt">删除</span>
                    </a>
                </li>
            </ul>
        </div>
        <div id="article_content" class="article_content csdn-tracking-statistics tracking-click" data-mod="popu_519" data-dsm="post">
                            <div class="htmledit_views">
                        
<h1><span style="font-size:24px;">一.无插件的实时通讯</span></h1>
<span style="font-size:18px;">       想像一下，如果你的手机、电视、电脑都可以通过一个平台进行通信，想像一下，你可以在Web应用中轻松地加入视频聊天和p2p数据分享，这就是WebRTC的愿景。<br />
       想试一试吗？WebRTC现在已经被集成到Chrome、Opera和Firefox，在<a href="https://apprtc.appspot.com/" title="Simple WebRTC demo" style="color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">apprtc.appspot.com</a>有个简单的视频聊天应用可供测试。<br />
1.在Chrome、Opera或Firefox中打开<a href="https://apprtc.appspot.com/" title="Simple WebRTC demo" style="color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">apprtc.appspot.com</a>。<br />
2.点击允许按钮允许应用启用你的摄像头。<br />
3.在新的选项卡中打开页面底部显示的URL，当然能在另外一台电脑上打开该URL会更好。<br /></span>
<p><span style="font-size:18px;">关于这个应用的具体教程详见“一个简单的视频聊天客户端”章节。</span></p>
<h1><span style="font-size:24px;">二.快速开始</span></h1>
<span style="font-size:18px;">       如果你没有时间阅读这篇文章，想直接编码，你可以这样：<br />
1.看一看Gooogle关于WebRTC的幻灯片（<a href="http://io13webrtc.appspot.com/" title="Google I/O 2013 WebRTC presentation" style="color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">here</a>)。<br />
2.你果你没有用过getUserMedia，要先学习一下它，教程：<a href="http://www.html5rocks.com/en/tutorials/getusermedia/intro/" title="HMTL5 Rocks: Capturing Audio and Video in HTML5" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><span style="color:#ff0000;">HTML5
 Rocks article</span></a>，例子：<a href="http://www.simpl.info/getusermedia" title="Simple getUserMedia example" style="color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">simpl.info/gum</a>。<br />
3.掌握RTCPeerConnection API，教程：本文的代码段，例子：<a href="http://www.simpl.info/pc" title="WebRTC demo without signaling" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><span style="color:#ff0000;">simpl.info/pc</span></a>，这个例子在一个单独的网页中实现了WebRTC。<br />
4.了解一下WebRTC信令服务、防火墙和NAT转发，教程：<a href="https://apprtc.appspot.com/" title="Simple WebRTC video chat demo" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><span style="color:#ff0000;">apprtc.appspot.com</span></a>。<br />
5.实在等不及了，可以通过这<a href="https://webrtc.github.io/samples" title="WebRTC Samples" style="color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">20+
 demos</a>练习WebRTC的JavaScript API。<br />
6.如果有什么问题，可以试试问题帮助页面<a href="https://test.webrtc.org/" title="WebRTC Troubleshooter" style="color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">test.webrtc.org</a>。<br />
       或者你可以直接跳到这一步：在<a href="https://www.bitbucket.org/webrtc/codelab" title="WebRTC codelab repository on Bitbucket" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><span style="color:#ff0000;">WebRTC
 codelab</span></a>上一步一步的学习如何构建一个完整的视频聊天应用程序，包括一个简单的信令服务器。<br /></span>
<h1><span style="font-size:24px;">三.关于WebRTC的小故事</span></h1>
<span style="font-size:18px;">       其实一个Web开发的终极挑战就是通过音频和视频进行实时通信，视频通信应该像文本通信一样自然，如果没有它，我们在用户交互方面的创新能力会受到限制。<br />
       在过去，实时通信都比较复杂，需要非常丰富的音频和视频技术才能进行开发。 完整的实现实时通信需要整合大量的数据和服务，在Web上实现尤其困难。<br />
       2008年，Gmail视频聊天火了。2011年谷歌发布了Hangouts，收购了GIPS，GIPS为RTC开发了许多组件，比如编码和回声消除技术。谷歌开源了GIPS的相关技术，并且与IETF和W3C等标准化组织达成了行业共识。2011年5月爱立信构建了第一个WebRTC应用。<br />
       WebRTC目前实现了实时、无插件的音频、视频和数据通信，我们迫切需要它，因为：<br />
1.许多web service在使用RTC，但是需要下载原生app或者插件，比如Skype、Facebook和谷歌Hangouts。<br />
2.下载、安装和升级插件非常繁琐，而且容易出错。<br />
3.插件不容易发现问题，测试很困难，大部分都需要授权，开发成本太高。<br />
       WebRTC项目的宗旨是：API是开源、免费的、标准的、可内建于浏览器且比其他现存的技术更加高效。<br /></span>
<h1><span style="font-size:24px;">四.WebRTC使用现状</span></h1>
<span style="font-size:18px;">       目前WhatsAPP、Facebook Messenger等应用都使用了WebRTC，不仅如此WebRTC还出现在其他平台中，比如TokBox。WebRTC可以被整合到WebKitGTK+或者Qt原生应用中。<br />
WebRTC实现了下列三个API：<br /></span>
<p><span style="font-size:18px;">1.<a href="https://www.html5rocks.com/en/tutorials/webrtc/basics/#toc-mediastream" title="Internal link to section for MediaStream (aka getUserMedia)" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><code style="font-family:'Source Code Pro', monospace;font-size:1em;"></code></a><a href="https://www.html5rocks.com/en/tutorials/webrtc/basics/#toc-mediastream" title="Internal link to section for MediaStream (aka getUserMedia)" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><code style="font-family:'Source Code Pro', monospace;font-size:1em;"><span style="color:#ff0000;">MediaStream</span></code></a><span style="color:rgb(192,192,192);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"></span>
 (别名getUserMedia)</span></p>
<p><span style="font-size:18px;">2.</span><a href="https://www.html5rocks.com/en/tutorials/webrtc/basics/#toc-rtcpeerconnection" title="Internal link to section for RTCPeerConnection" style="font-family:'Source Code Pro', monospace;line-height:27px;"><span style="font-size:18px;color:#ff0000;">RTCPeerConnection</span></a></p>
<span style="font-size:18px;">3.</span><a href="https://www.html5rocks.com/en/tutorials/webrtc/basics/#toc-rtcdatachannel" title="Internal link to section about RTCDataChannel" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><code style="font-family:'Source Code Pro', monospace;font-size:1em;"><span style="color:#ff0000;">RTCDataChannel</span></code></a><span style="font-size:18px;"><br />
       getUserMedia可用于Chrome、Opera、Firefox和Edge。你可以看看这个跨浏览器的<a href="https://webrtc.github.io/samples/src/content/getusermedia/gum/" title="Simple cross-platform getUserMedia demo" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><span style="color:#ff0000;">demo</span></a>和Chris
 Wilson的<a href="http://webaudiodemos.appspot.com/" title="" style="color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">amazing examples</a>，这些例子使用getUserMedia作为音频的输入。<br />
       RTCPeerConnection可用于Chrome、Opera和Firefox。经过几次迭代之后RTCPeerConnection被Chrome和Opera实现为webkitRTCPeerConnection，被Firefox实现为mozRTCPeerConnection。其他的实现已经被废弃。当标准化进程稳定之后，这两个实现名字的前缀会被移除。Chromium的一个超级简单的RTCPeerConnection实现在<a href="https://webrtc.github.io/samples/src/content/peerconnection/pc1/" title="Simple cross-platform peerconnection demo" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><span style="color:#ff0000;">GitHub</span></a>上，大量的视频聊天应用在<a href="https://apprtc.appspot.com/" title="Video chat demo" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><span style="color:#ff0000;">apprtc.appspot.com</span></a>。<br />
       RTCDataChannel可用于Chrome、Opera和Firefox。在<a href="https://webrtc.github.io/samples/" title="WebRTC samples" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><span style="color:#ff0000;">GitHub</span></a>上有关于数据通道的例子，可以去实践一下。<br /></span>
<h1><span style="font-size:24px;">五.我的第一个WebRTC应用</span></h1>
<span style="font-size:18px;">       开发WebRTC应用需要做好下列准备：<br />
1.获取音视频流或者其他数据<br />
2.得到网络信息，如IP地址和端口，通过网络和其它WebRTC客户端交换数据，解决NATs/防火墙穿透问题。<br />
3.协调信令通信来报告错误、启动或关闭会话。<br />
4.交换媒体和客户端信息，比如分辨率和编解码参数。<br />
5.传输音视频流或者其他数据。<br />
       为了实现数据流通信，WebRTC实现了下列API：<br />
1.<code style="font-size:1em;line-height:27px;"><span style="font-size:18px;line-height:27px;"><a href="https://www.html5rocks.com/en/tutorials/webrtc/basics/#toc-mediastream" title="Internal link to section for MediaStream (aka getUserMedia)" style="color:rgb(255,0,0);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><span style="color:#ff0000;">MediaStream</span></a><span style="font-family:'Source Code Pro', monospace;">：</span></span></code>从设备获取数据流，比如说摄像头和麦克风。<br />
2.<a href="https://www.html5rocks.com/en/tutorials/webrtc/basics/#toc-rtcpeerconnection" title="Internal link to section for RTCPeerConnection" style="font-family:'Source Code Pro', monospace;line-height:27px;"><span style="font-size:18px;"><span style="color:#ff0000;">RTCPeerConnection</span></span></a>：音视频通话，包括设备加密和带宽管理。<br />
3.<a href="https://www.html5rocks.com/en/tutorials/webrtc/basics/#toc-rtcdatachannel" title="Internal link to section about RTCDataChannel" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><code style="font-family:'Source Code Pro', monospace;font-size:1em;"><span style="color:#ff0000;">RTCDataChannel</span></code></a>：p2p通信。<br /></span>
<h1><span style="font-size:24px;">六.MediaStream (别名getUserMedia)</span></h1>
<span style="font-size:18px;"><span style="color:#ff0000;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">       <a href="http://dev.w3.org/2011/webrtc/editor/getusermedia.html" title="W3C Editor's Draft: Media Capture and Streams" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><span style="color:#ff0000;">MediaStream
 API</span></a></span>代表媒体流的同步。比如，从摄像头和麦克风获取的媒体流具有同步视频和音频轨道。不要将这里的<span style="font-size:18px;">MediaStream</span>轨道和&lt;track&gt;元素混淆，它们是完全不同的概念。<br />
理解MediaStream最简单的方法如下：<br />
1.在Chrome或Opera中打开例子<a href="https://webrtc.github.io/samples/src/content/getusermedia/gum/" title="getUserMedia demo" style="color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">https://webrtc.github.io/samples/src/content/getusermedia/gum</a><br />
2.打开控制台<br />
3.检查stream变量，该变量是全局的。<br />
       每个MediaStream都有输入，即navigator.getUserMedia()；也有输出，被传递到video元素或RTCPeerConnection<br />
getUserMedia()方法有三个参数：<br />
1.一个约束对象。<br />
2.一个成功的回调，如果成功会回传一个MediaStream。<br />
3.一个失败的回调，如果失败会回传一个error对象。<br />
       每个MediaStream都有一个label，比如'Xk7EuLhsuHKbnjLWkW4yYGNJJ8ONsgwHBvLQ'，getAudioTradks()和getAudioTracks()方法会回传一个MediaStreamTracks对象的数组。<br />
在例子<a href="https://webrtc.github.io/samples/src/content/getusermedia/gum/" title="getUserMedia demo" style="color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">https://webrtc.github.io/samples/src/content/getusermedia/gum</a>中,stream.getAudioTracks()回传了一个空数组（因为没有音频），假设摄像头正常工作并连接，stream.getVideoTracks()回传一个MediaStreamTracks对象的数组。数组中的每个MediaStreamTracks对象包含一种媒体（‘video’或‘audio’）和一个label（比如'FaceTime
 HD Camera (Built-in)'），而且还代表了一个或多个音视频的数据通道。在这个例子中，只有一个视频轨道，没有音频。当然，很容易就能扩展到其他情况。<br />
       在Chrome或Opera中, URL.createObjectURL()方法将<span style="font-size:18px;">MediaStream</span>转换成<a href="http://www.html5rocks.com/tutorials/workers/basics/#toc-inlineworkers-bloburis" title="HTML5 Rocks: Blob URLs" style="color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">Blob
 URL</a>，该Blob URL可以设置为video元素的输入（在Firefox和Opera中，视频源可以通过数据流本身设置）。版本M25开始，基于Chromium的浏览器（Chrome和Opera）允许来自getUserMedia的音频数据传递到aduio或video元素。<br />
       getUserMedia还可用作<a href="https://developers.google.com/web/updates/2012/09/Live-Web-Audio-Input-Enabled"><span style="color:#ff0000;">Web Audio API的输入节点</span></a>。<br /></span><span style="font-size:18px;"></span><pre class="cpp">function gotStream(stream) {
    window.AudioContext = window.AudioContext || window.webkitAudioContext;
    var audioContext = new AudioContext();

    // Create an AudioNode from the stream
    var mediaStreamSource = audioContext.createMediaStreamSource(stream);

    // Connect it to destination to hear yourself
    // or any other node for processing!
    mediaStreamSource.connect(audioContext.destination);
}
navigator.getUserMedia({audio:true}, gotStream);</pre><span style="font-size:18px;">       在manifest中添加audioCapture和videoCapture权限可以在加载的时候得到（仅一次）授权，毕竟加载之后用户不会再有对摄像头或麦克风的访问请求。<br />
       最终的目的是使MediaStream适用于任何数据源，不仅限于摄像头和麦克风，还包括来自磁盘或者传感器等输入设备二进制数据。<br />
       需要注意的是getUserMedia()必须在服务器上使用，而不是本地文件中，否则的话将会抛出权限的错误PERMISSION_DENIED。<br />
       getUserMedia()通常和其他的JavaScript API及库一起使用:</span><br /><span style="font-size:18px;"><a href="http://webcamtoy.com/app/" title="Webcam Toy site" style="color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:27px;">Webcam Toy</a>是一个photobooth应用，它使用WebGL来添加一些特效，让用户可以共享照片或是保存到本地。<br /><a href="http://www.shinydemos.com/facekat/" title="FaceKat game" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:27px;"><span style="color:#ff0000;">FaceKat</span></a>是一个人脸追踪的游戏，使用headtrackr.js。<br /></span>
<p><span style="font-size:18px;"><a href="http://idevelop.ro/ascii-camera/" title="'ASCII camera' demo" style="color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:27px;">ASCII
 Camera</a>使用Canvas API来生成AS</span><span style="font-size:18px;">CII码的图片。</span></p>
<h1><span style="font-size:24px;">七.约束</span></h1>
<span style="font-size:18px;">       <a href="http://tools.ietf.org/html/draft-alvestrand-constraints-resolution-00#page-4" title="IETF Resolution Constraints draft specification" style="color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">Constraints</a>已经在Chrome、FireFox和Opera中实现了。通过约束可以设置getUserMedia()和RTCPeerConnection的addStream()获取视频的分辨率，约束的实现是为了通过applyConstraints()方法控制视频高度和宽度的比例、帧率、和正反摄像头模式等等……<br />
       这里有一个例子：<a href="https://webrtc.github.io/samples/src/content/getusermedia/resolution/l" title="Resolution Constraints example on GitHub" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><span style="color:#ff0000;">https://webrtc.github.io/samples/src/content/getusermedia/resolution/</span></a>。<br />
       一个陷阱：getUserMedia约束设置在浏览器的一个标签中，会约束之后打开的所有标签。设置一个非法的值会提示以下错误：<br /></span><pre class="cpp">navigator.getUserMedia error:
NavigatorUserMediaError {code: 1, PERMISSION_DENIED: 1}</pre>
<h1><span style="font-size:24px;">八.屏幕和标签捕获</span></h1>
<span style="font-size:18px;">       Chrome应用可以通过chrome.tabCapture和chrome.desktopCapture这两个API实时分享浏览器标签或者整个桌面。桌面捕获的例子：<a href="https://github.com/webrtc/samples/tree/master/src/content/getusermedia/desktopcapture" title="Desktop capture extension demo" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><span style="color:#ff0000;">WebRTC
 samples GitHub repository</span></a>。更多关于屏幕录制、编码的信息和有参考：<a href="http://updates.html5rocks.com/2012/12/Screensharing-with-WebRTC" title="HTML5 Rocks update article: Screensharing with WebRTC" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><span style="color:#ff0000;">Screensharing
 with WebRTC</span></a><span style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;color:#555555;"><span style="line-height:27px;">。</span></span><br />
       在Chrome中，可以将屏幕捕获当做MediaStream的数据源，此时使用的是实验性的chromeMediaSource约束，一个例子：<a href="https://html5-demos.appspot.com/static/getusermedia/screenshare.html" title="Screenshare demo" style="color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">this
 demo</a>。需要注意的是屏幕捕获功能需要HTTPS支持，并且只用于开发中，通过一个命令行标志来启用。<br /></span>
<h1><span style="font-size:24px;">九.信令：会话控制，网络和媒体信息</span></h1>
<span style="font-size:18px;">       WebRTC使用RTCPeerConnection在浏览器（别名peer）之间互通数据流，但是需要一种机制去协调通信或者发送控制消息，这个过程被称为信令。WebRTC没有指定信令方法和协议，信令不是RTCPeerConnection API的一部分。</span><br /><span style="font-size:18px;">       因此，WebRTC应用的开发者可用选择其擅长的消息协议，比如SIP或XMPP，或者其他合适的双工通信协议。</span><br /><a href="https://apprtc.appspot.com/" title="apprtc WebRTC example" style="font-size:18px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:27px;"><span style="color:#ff0000;">apprtc.appspot.com</span></a><span style="font-size:18px;">这个例子使用XHR和Channel
 API作为信令机制。</span><a href="http://www.bitbucket.org/webrtc/codelab" title="WebRTC codelab" style="font-size:18px;color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:27px;">codelab</a><span style="font-size:18px;">是我们通过</span><a href="http://socket.io/" title="Socket.io website" style="font-size:18px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:27px;"><span style="color:#ff0000;">Socket.io</span></a><span style="font-size:18px;">构建，运行在</span><a href="http://nodejs.org/" title="Node website" style="font-size:18px;color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:27px;">Node
 server</a><span style="font-size:18px;">上的应用。</span><br /><span style="font-size:18px;">       信令通常用于交互三类信息：</span><br /><span style="font-size:18px;">1.会话控制消息；初始化或者关闭通信，报告错误。</span><br /><span style="font-size:18px;">2.网络信息：对于外部而言，我的IP地址和端口是什么？</span><br /><span style="font-size:18px;">3.媒体信息：什么编码和分辨率浏览器可以处理，我的浏览器要和谁通信。</span><br /><span style="font-size:18px;">       在p2p的流传输之前，必须通过信令成功的交换信息。</span><br /><span style="font-size:18px;">       假如Alice想和Bob通信，这里有个简单的例子来自</span><a href="http://www.w3.org/TR/webrtc/#simple-example" title="WebRTC 1.0: Real-time Communication Between Browsers" style="font-size:18px;color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:27px;">WebRTC
 W3C Working Draft</a><span style="font-size:18px;">，展示了实际的信令处理过程。例子中假设存在某种信令机制，该机制通过createSignalingChannel()方法创建。注意在Chrome和Opera中，RTCPeerConnection是带有前缀的。</span><br /><pre class="cpp" style="font-size:18px;">var signalingChannel = createSignalingChannel();
var pc;
var configuration = ...;

// run start(true) to initiate a call
function start(isCaller) {
    pc = new RTCPeerConnection(configuration);

    // send any ice candidates to the other peer
    pc.onicecandidate = function (evt) {
        signalingChannel.send(JSON.stringify({ "candidate": evt.candidate }));
    };

    // once remote stream arrives, show it in the remote video element
    pc.onaddstream = function (evt) {
        remoteView.src = URL.createObjectURL(evt.stream);
    };

    // get the local stream, show it in the local video element and send it
    navigator.getUserMedia({ "audio": true, "video": true }, function (stream) {
        selfView.src = URL.createObjectURL(stream);
        pc.addStream(stream);

        if (isCaller)
            pc.createOffer(gotDescription);
        else
            pc.createAnswer(pc.remoteDescription, gotDescription);

        function gotDescription(desc) {
            pc.setLocalDescription(desc);
            signalingChannel.send(JSON.stringify({ "sdp": desc }));
        }
    });
}

signalingChannel.onmessage = function (evt) {
    if (!pc)
        start(false);

    var signal = JSON.parse(evt.data);
    if (signal.sdp)
        pc.setRemoteDescription(new RTCSessionDescription(signal.sdp));
    else
        pc.addIceCandidate(new RTCIceCandidate(signal.candidate));
};</pre><span style="font-size:18px;">       首先，Alice和Bob交换网络信息，‘finding candidates’表示通过</span><a href="https://www.html5rocks.com/en/tutorials/webrtc/basics/#ice" title="Internal link to more information about the ICE framework" style="font-size:18px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:27px;"><span style="color:#ff0000;">ICE
 framework</span></a><span style="font-size:18px;">查找网络接口和端口。</span><br /><span style="font-size:18px;">1.Alice创建一个RTCPeerConnection对象，该对象内置onicecandidate处理器。</span><br /><span style="font-size:18px;">2.这个处理器在网络</span><span style="color:rgb(85,85,85);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:27px;"><span style="font-size:18px;">candidate</span></span><span style="font-size:18px;color:rgb(85,85,85);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:27px;">生效时</span><span style="font-size:18px;">开始运行。</span><br /><span style="font-size:18px;">3.Alice通过信令通道发送序列化的数据给Bob，信令通道可以是WebSocket或者其他机制。</span><br /><span style="font-size:18px;">4.当Bob收到Alice的<span style="color:rgb(85,85,85);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">candidate</span>消息后，调用addIceCandidate将<span style="color:rgb(85,85,85);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">candidate</span>添加到远端描述。</span><br /><span style="font-size:18px;">        WebRTC客户端（别名peer，这里指Alice和Bob）需要明确并交换本地和远程音视频媒体信息，比如分辨率和编码格式。交换媒体信息的信令，是通过</span><span style="font-size:18px;">交换会话描述协议（SDP）来实现的。</span><br /><span style="font-size:18px;">1.Alice调用了RTCPeerConnection的createOffer()方法，它的回调参数传入的是RTCSessionDescription（Alice的本地会话描述）。</span><br /><span style="font-size:18px;">2.在回调中，Alice调用setLocalDescription()方法设置了本地会话描述，然后将该会话描述通过信令通道发送给Bob。注意，RTCPeerConnection并不会采集</span><span style="font-size:18px;"><span style="color:rgb(85,85,85);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">candidate</span>直到setLocalDescription()被调用。</span><br /><span style="font-size:18px;">3.Bob使用setRemoteDescription()方法将Alice发送给他的会话描述设置为远程会话描述。</span><br /><span style="font-size:18px;">4.Bob调用了RTCPeerConnection的createAnswer()方法，并传入它从Alice接收到的远程会话描述，此时一个与Alice兼容的本地会话产生了。</span><span style="font-size:18px;">createAnswer()的回调参数传入的是RTCSessionDescription（Bob将它设置为本地会话描述并发送给Alice）。</span><br /><span style="font-size:18px;">5.当Alice收到Bob的会话描述，她使用setRemoteDescription()方法将其设置为远程会话描述。</span><br /><span style="font-size:18px;">6.Ping</span><br /><span style="font-size:18px;">       RTCSessionDescription对象遵从SDP（Session Description Protocol），一个SDP对象看起来如下所示：</span><br /><pre class="cpp">v=0
o=- 3883943731 1 IN IP4 127.0.0.1
s=
t=0 0
a=group:BUNDLE audio video
m=audio 1 RTP/SAVPF 103 104 0 8 106 105 13 126

// ...

a=ssrc:2223794119 label:H4fjnMzxy3dPIgQ7HxuCTLb4wLLLeRHnFxh810</pre><span style="font-size:18px;">       交换网络和媒体信息可以同时进行，但这两个过程必须在音视频流开始传输之前完成。</span><br /><p><span style="font-size:18px;">      上述的offer/answer架构被称为<a href="http://tools.ietf.org/html/draft-ietf-rtcweb-jsep-00" title="IETF JSEP draft proposal" style="color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">JSEP</a>（JavaScript
 Session Establishment Protocol），JSEP架构如下所示：</span></p>
<p><span style="font-size:18px;"><img src="http://img.blog.csdn.net/20161124092130177?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /><br /></span></p>
<span style="font-size:18px;">      一旦信令过程成功，就可以直接进行Caller和callee之间p2p的数据流传输了。</span><br /><h1><span style="font-size:24px;">十.RTCPeerConnection</span></h1>
<span style="font-size:18px;">RTCPeerConnection是WebRTC的组件，用来稳定高效的处理端对端的数据流通信。</span><br /><p><span style="font-size:18px;">下图是WebRTC的架构图，标明了RTCPeerConnection扮演的角色。你可能注意到了，绿色部分是相当复杂的。</span></p>
<p><span style="font-size:18px;"><img src="http://img.blog.csdn.net/20161124092310164?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /><br /></span></p>
<span style="font-size:18px;">       从JavaScript的角度来看，理解这个图最重要的是理解RTCpeerConnection这一部分。WebRTC对编解码器和协议做了大量的工作，使实时通信成为可能，甚至在一些不可靠的网络中：</span><br /><span style="font-size:18px;">1.包补偿</span><br /><span style="font-size:18px;">2.回声消除</span><br /><span style="font-size:18px;">3.自适应带宽</span><br /><span style="font-size:18px;">4.视频抖动缓冲</span><br /><span style="font-size:18px;">5.自动增益控制</span><br /><span style="font-size:18px;">6.噪声抑制</span><br /><span style="font-size:18px;">7.图像清除</span><br /><span style="font-size:18px;">       章节九中的例子从信令的角度进行了讲解，下面我们将学习两个WebRTC应用；一个简单的演示了RTCPeerConnection，另一个是功能齐全的视频聊天客户端。</span><br /><h1><span style="font-size:24px;">十一.无服务器的RTCPeerConnection</span></h1>
<span style="font-size:18px;">       下面的代码来自<a href="https://webrtc.github.io/samples/src/content/peerconnection/pc1/" title="WebRTC demo without signaling" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><span style="color:#ff0000;">https://webrtc.github.io/samples/src/content/peerconnection/pc1</span></a>，包含基于网页的本地和远程RTCPeerConnection。这个例子中caller和callee</span><span style="font-size:18px;">在同一个网页中，能更加清晰的展示RTCPeerConnection
 API的工作流程，因为RTCPeerConnection对象之间可以直接交换数据和消息，不需要通过中继信道机制。</span><br /><span style="font-size:18px;">       一个陷阱：RTCPeerConnection()第二个约束类型的参数是可选的，它与getUserMedia()中使用的约束类型不同。</span><br /><span style="font-size:18px;">       本例中pc1表示本地端（caller），pc2表示远程端（callee）</span><br /><strong><span style="font-size:24px;">caller</span></strong><br /><span style="font-size:18px;">1.创建一个RTCPeerConnection，并通过getUserMedia()添加数据流。</span><br /><pre class="cpp">// servers is an optional config file (see TURN and STUN discussion below)
pc1 = new webkitRTCPeerConnection(servers);
// ...
pc1.addStream(localStream); </pre><span style="font-size:18px;">2.创建一个offer，并将它设置为pc1的本地会话描述，设置为pc2的远程会话描述。可以直接在代码中设置，不需要使用信令，因为caller和callee在同一个网页中。</span><br /><pre class="cpp">pc1.createOffer(gotDescription1);
//...
function gotDescription1(desc){
  pc1.setLocalDescription(desc);
  trace("Offer from pc1 \n" + desc.sdp);
  pc2.setRemoteDescription(desc);
  pc2.createAnswer(gotDescription2);
}</pre><strong><span style="font-size:24px;">callee</span></strong><br /><span style="font-size:18px;">1.创建pc2，接收pc1的数据流，并显示到video元素中</span><br /><pre class="cpp">pc2 = new webkitRTCPeerConnection(servers);
pc2.onaddstream = gotRemoteStream;
//...
function gotRemoteStream(e){
  vid2.src = URL.createObjectURL(e.stream);
}</pre>
<h1><span style="font-size:24px;">十二.有服务器的RTCPeerConnection</span></h1>
<span style="font-size:18px;">       实际应用中，WebRTC需要服务器，无论多简单，下面四步是必须的：</span><br /><span style="font-size:18px;">1.用户通过交换名字之类的信息发现对方。</span><br /><span style="font-size:18px;">2.WebRTC客户端应用交换网络信息。</span><br /><span style="font-size:18px;">3.客户端交换媒体信息包括视频格式和分辨率。</span><br /><span style="font-size:18px;">4.WebRTC客户端穿透NAT网关和服务器。</span><br /><span style="font-size:18px;">       换句话说，WebRTC需要四种类型的服务端功能。</span><br /><span style="font-size:18px;">1.用户发现和通信</span><br /><span style="font-size:18px;">2.信令</span><br /><span style="font-size:18px;">3.NAT/防火墙穿透</span><br /><span style="font-size:18px;">4.中继服务器，防止端到端的通信失败</span><br /><span style="font-size:18px;">       以上这些不在本文讨论范围之内。可以说基于<a href="http://en.wikipedia.org/wiki/STUN" title="Wikipedia STUN article" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><span style="color:#ff0000;">STUN</span></a>和<a href="http://en.wikipedia.org/wiki/Traversal_Using_Relay_NAT" title="Wikipedia article about TURN" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><span style="color:#ff0000;">TURN</span></a>协议的<a href="http://en.wikipedia.org/wiki/Interactive_Connectivity_Establishment" title="Wikipedia article about ICE" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><span style="color:#ff0000;">ICE</span></a>框架，使得RTCPeerConnection处理NAT穿透和其他网络难题成为可能。</span><br /><span style="font-size:18px;">       ICE框架用于端到端的连接，比如说两个视频聊天客户端。起初，ICE尝试通过UDP直接连接两端，这样可以保证低延迟。在这个过程中，STUN</span><span style="font-size:18px;">服务器有一个简单的任务：使NAT后边的端能找到它的公网地址和端口（谷歌有多个STUN服务器，其中一个用在了apprtc.appspot.com例子）。</span><br /><img src="http://img.blog.csdn.net/20161124093715622?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /><br /><br /><p><span style="font-size:18px;">       如果UDP传输失败，ICE会尝试TCP：首先是HTTP，然后才会选择 HTTPS。如果直接连接失败，通常因为企业的NAT穿透和防火墙，此时ICE使用中继（Relay）服务器。换句话说，ICE首先使用STUN和UDP直接连接两端，失败之后返回中继服务器。‘finding cadidates’就是寻找网络接口和端口的过程。</span></p>
<p><span style="font-size:18px;"><img src="http://img.blog.csdn.net/20161124094143641?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /><br /></span></p>
<span style="font-size:18px;">       WebRTC工程师Justin Uberti在幻灯片<a href="https://www.youtube.com/watch?v=p2HzZkd2A40&amp;t=21m12s" title="Google I/O WebRTC presentation: discussion of ICE, STUN and TURN" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><span style="color:#ff0000;">2013
 Google I/O WebRTC presentation</span></a>中提供了许多关于ICE、STUN和TURN的信息。</span><br /><h1><span style="font-size:24px;">十三.一个简单的视频聊天客户端</span></h1>
<span style="font-size:18px;">       如果你觉得这个例子比较难，你也行会喜欢上我们的<a href="https://www.bitbucket.org/webrtc/codelab" title="WebRTC codelab repository on Bitbucket" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;font-style:italic;line-height:25.2px;"><span style="color:#ff0000;">WebRTC
 codelab</span></a>。那里一步步的介绍了如何建立一个完整的视频聊天应用，包括</span><span style="font-size:18px;">一个运行于<a href="http://nodejs.org/" title="Node website" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;font-style:italic;line-height:25.2px;"><span style="color:#ff0000;">Node
 server</span></a>上基于<a href="http://socket.io/" title="Socket.io website" style="color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;font-style:italic;line-height:25.2px;">Socket.io</a>的信令服务器。</span><br /><span style="font-size:18px;">       <a href="https://apprtc.appspot.com/" title="Simple WebRTC demo" style="color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">apprtc.appspot.com</a>是一个测试WebRTC的好地方，里面有视频聊天的例子，它实现了信令和基于STUN服务器的NAT/防火墙穿透。</span><span style="font-size:18px;">这个例子使用<a href="https://github.com/webrtc/adapter" title="adapter.js JavaScript file" style="color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">adapter.js</a>处理不同的RTCPeerConnection和getUserMedia()实现。</span><br /><p><span style="font-size:18px;">       下面我们详细的过一遍代码。</span></p>
<p><strong><span style="font-size:24px;">如何开始</span></strong><br /></p>
<span style="font-size:18px;">这个例子从initialize()函数开始运行。</span><br /><pre class="cpp">function initialize() {
    console.log("Initializing; room=99688636.");
    card = document.getElementById("card");
    localVideo = document.getElementById("localVideo");
    miniVideo = document.getElementById("miniVideo");
    remoteVideo = document.getElementById("remoteVideo");
    resetStatus();
    openChannel('AHRlWrqvgCpvbd9B-Gl5vZ2F1BlpwFv0xBUwRgLF/* ...*/');
    doGetUserMedia();
  }</pre><span style="font-size:18px;">       需要注意的是，变量room和openChannel()参数的值都是由Google App Engine应用自身提供的。</span><span style="font-size:18px;">查看一下<a href="https://github.com/webrtc/apprtc/blob/master/src/web_app/html/index_template.html" title="index.html template code in the apprtc repository" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><span style="color:#ff0000;">index.html</span></a><a href="https://github.com/webrtc/apprtc/blob/master/src/web_app/html/index_template.html" title="index.html template code in the apprtc repository" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><span style="color:#ff0000;">
 template</span></a> 就知道该赋什么值了。</span><br /><span style="font-size:18px;">       这段代码初始化HTML video元素的相关变量，video元素播放来自本地摄像头（localVieo）和远程摄像头（remoteVideo）的视频流。</span><span style="font-size:18px;">resetStatus()设置了一条状态消息。</span><br /><span style="font-size:18px;">       openChannel()函数建立了WebRTC客户端间的消息通道。</span><br /><pre class="cpp">function openChannel(channelToken) {
  console.log("Opening channel.");
  var channel = new goog.appengine.Channel(channelToken);
  var handler = {
    'onopen': onChannelOpened,
    'onmessage': onChannelMessage,
    'onerror': onChannelError,
    'onclose': onChannelClosed
  };
  socket = channel.open(handler);
}</pre>
<p><span style="font-size:18px;">关于信令，本例使用的是Google App Engine <a href="http://code.google.com/appengine/docs/python/channel/overview.html" title="Channel API Overview (Python)" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">
<span style="color:#ff0000;">Channel API</span></a>，这使得JavaScritp客户端无需轮询就能实现消息传输。</span></p>
<p><span style="font-size:18px;"><img src="http://img.blog.csdn.net/20161124095413177?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /><br /></span></p>
<span style="font-size:18px;">       使用Channel API建立通道的流程大致如下：</span><br /><span style="font-size:18px;">1.客户端A生成一个唯一ID。</span><br /><span style="font-size:18px;">2.客户端A向Google App Engine应用请求一个通道标识（即openChannel()的参数），并将它的ID传给Google App Engine应用。</span><br /><span style="font-size:18px;">3.Google App Engine应用会调用Channel API为客户端ID分配一个通道和一个通道标识。</span><br /><span style="font-size:18px;">4.Google App Engine应用将通道标识发给客户端A。</span><br /><p><span style="font-size:18px;">5.客户端A打开socket并监听服务器上建立的通道。</span></p>
<p><span style="font-size:18px;"><img src="http://img.blog.csdn.net/20161124095706586?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /><br /></span></p>
<span style="font-size:18px;">       发送消息的流程大致如下：</span><br /><span style="font-size:18px;">1.客户端B给Google App Engine应用发送了一个POST请求，要求升级程序。</span><br /><span style="font-size:18px;">2.Google App Engine应用给通道发送一个请求消息。</span><br /><span style="font-size:18px;">3.消息经通道传递给客户端A</span><br /><p><span style="font-size:18px;">4.客户端A的onmessage回调函数被调用。</span></p>
<p><span style="font-size:18px;"><img src="http://img.blog.csdn.net/20161124095911554?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /><br /></span></p>
<span style="font-size:18px;">       重申一次，信令传输机制是由开发者选择的。WebRTC并没有指定信令机制。本例的Channel API能被其他的方式取代，比如WebSocket。</span><br /><span style="font-size:18px;">       initialize()调用完openChannel()之后，紧接着调用getUserMedia()，这个函数可以检测出浏览器是否支持getUserMedia API。如果一切顺利，</span><span style="font-size:18px;">onUserMediaSuccess会被调用。</span><br /><pre class="cpp">function onUserMediaSuccess(stream) {
  console.log("User has granted access to local media.");
  // Call the polyfill wrapper to attach the media stream to this element.
  attachMediaStream(localVideo, stream);
  localVideo.style.opacity = 1;
  localStream = stream;
  // Caller creates PeerConnection.
  if (initiator) maybeStart();
}</pre><span style="font-size:18px;">       这样一来，本地摄像头就能显示在localVideo元素中了。</span><br /><span style="font-size:18px;">       此时，initiator被设置成1（直到caller的会话终止），maybeStart()被调用。</span><br /><pre class="cpp">function maybeStart() {
  if (!started &amp;&amp; localStream &amp;&amp; channelReady) {
    // ...
    createPeerConnection();
    // ...
    pc.addStream(localStream);
    started = true;
    // Caller initiates offer to peer.
    if (initiator)
      doCall();
  }
}</pre><span style="font-size:18px;">       该函数使用了一种巧妙的结构，可以工作于多个异步回调：maybeStart()可能被任何函数调用，但是只有当localStream被定义、channelReady为true且通信还未开始的情况下，maybeStart()才会运行。</span><span style="font-size:18px;">因此，当连接还未建立，本地流已经可用，且信令通道已经准备好时，连接才会创建并加载本地视频流。接着started被设置为true。所以连接不会被创建多次
 。</span><br /><span style="font-size:24px;"><strong>RTCPeerConnection: 发起通话</strong></span><br /><span style="font-size:18px;">       在maybeStart()中被调用的createPeerConnection()，才是关键所在。</span><br /><pre class="cpp">function createPeerConnection() {
  var pc_config = {"iceServers": [{"url": "stun:stun.l.google.com:19302"}]};
  try {
    // Create an RTCPeerConnection via the polyfill (adapter.js).
    pc = new RTCPeerConnection(pc_config);
    pc.onicecandidate = onIceCandidate;
    console.log("Created RTCPeerConnnection with config:\n" + "  \"" +
      JSON.stringify(pc_config) + "\".");
  } catch (e) {
    console.log("Failed to create PeerConnection, exception: " + e.message);
    alert("Cannot create RTCPeerConnection object; WebRTC is not supported by this browser.");
      return;
  }

  pc.onconnecting = onSessionConnecting;
  pc.onopen = onSessionOpened;
  pc.onaddstream = onRemoteStreamAdded;
  pc.onremovestream = onRemoteStreamRemoved;
}</pre><span style="font-size:18px;">       这段代码的目的是使用STUN服务器建立一个连接，并将onIceCandidate()作为回调函数。</span><span style="font-size:18px;">然后给RTCPeerConnection每个事件指定处理器（函数）：当会话连接或打开，当远程流被加载或移除。</span><span style="font-size:18px;">在本例中，这些处理器只是记录了状态消息——除了onRemoteStreamAdded()，它给remoteVideo元素设置了数据源。</span><br /><pre class="cpp">function onRemoteStreamAdded(event) {
  // ...
  miniVideo.src = localVideo.src;
  attachMediaStream(remoteVideo, event.stream);
  remoteStream = event.stream;
  waitForRemoteVideo();
}</pre><span style="font-size:18px;">       一旦createPeerConnection()在maybeStart()中被调用，就会发起通话，创建Offer并发送消息给对端。</span><br /><pre class="cpp">function doCall() {
  console.log("Sending offer to peer.");
  pc.createOffer(setLocalAndSendMessage, null, mediaConstraints);
}</pre><span style="font-size:18px;">       这里的offer创建过程类似于上面无信令的例子。但是，除此之外，一条消息被发送到了对端，详见setLocalAndSendMessage()：</span><br /><pre class="cpp">function setLocalAndSendMessage(sessionDescription) {
  // Set Opus as the preferred codec in SDP if Opus is present.
  sessionDescription.sdp = preferOpus(sessionDescription.sdp);
  pc.setLocalDescription(sessionDescription);
  sendMessage(sessionDescription);
}</pre><span style="font-size:24px;"><strong>用Channel API传输信令</strong></span><br /><span style="font-size:18px;">        当RTCPeerConnection在createPeerConnection()中成功创建的时候，onIceCandidate()回调函数会触发，并发送关于<span style="color:rgb(85,85,85);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">candidate</span>的信息。</span><br /><pre class="cpp">function onIceCandidate(event) {
    if (event.candidate) {
      sendMessage({type: 'candidate',
        label: event.candidate.sdpMLineIndex,
        id: event.candidate.sdpMid,
        candidate: event.candidate.candidate});
    } else {
      console.log("End of candidates.");
    }
  }
</pre>
<p><span style="font-size:18px;">        从客户端到服务器的消息外传，是通过sendMessage()方法内的XHR请求实现的。</span></p>
<p><span style="font-size:18px;"></span></p>
<pre class="cpp">function sendMessage(message) {
  var msgString = JSON.stringify(message);
  console.log('C-&gt;S: ' + msgString);
  path = '/message?r=99688636' + '&amp;u=92246248';
  var xhr = new XMLHttpRequest();
  xhr.open('POST', path, true);
  xhr.send(msgString);
}</pre>
<p></p>
<span style="font-size:18px;">        XHR多用于从客户端发送信令消息到服务端，但是某些机制需要用来实现服务端到客户端的消息传输：本例用的是Google App Engine Channel API。</span><span style="font-size:18px;">来自此API的消息会传递到processSignalingMessage()：</span><br /><pre class="cpp">function processSignalingMessage(message) {
  var msg = JSON.parse(message);

  if (msg.type === 'offer') {
    // Callee creates PeerConnection
    if (!initiator &amp;&amp; !started)
      maybeStart();

    pc.setRemoteDescription(new RTCSessionDescription(msg));
    doAnswer();
  } else if (msg.type === 'answer' &amp;&amp; started) {
    pc.setRemoteDescription(new RTCSessionDescription(msg));
  } else if (msg.type === 'candidate' &amp;&amp; started) {
    var candidate = new RTCIceCandidate({sdpMLineIndex:msg.label,
                                         candidate:msg.candidate});
    pc.addIceCandidate(candidate);
  } else if (msg.type === 'bye' &amp;&amp; started) {
    onRemoteHangup();
  }
}</pre><span style="font-size:18px;">       如果消息是来自对端的answer（offer的回应），RTCPeerConnection设置远程会话描述，通信开始。</span><span style="font-size:18px;">如果消息是offer（来自callee），RTCPeerConnection设置远程会话描述，发送answer给callee，然后调用RTCPeerConnection的startIce()方法发起连接。</span><br /><pre class="cpp">function doAnswer() {
  console.log("Sending answer to peer.");
  pc.createAnswer(setLocalAndSendMessage, null, mediaConstraints);
}</pre><span style="font-size:18px;">       于是乎，caller和callee都发现了对方并交换相关信息，会话被初始化，实时数据通信可以开始了。</span><br /><span style="font-size:24px;"><strong>网络技术</strong></span><br /><p><span style="font-size:18px;">       WebRTC目前只实现了一对一的通信，但是可用于更复杂的网络环境：比如，多个peer各自直接通信，即p2p；或者通过MCU（<a href="http://en.wikipedia.org/wiki/Multipoint_control_unit" title="MCU article on Wikipedia" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><span style="color:#ff0000;">Multipoint
 Control Unit</span></a>）服务器来实现流的转发、合成或音视频的录制。</span></p>
<p><span style="font-size:18px;"><img src="http://img.blog.csdn.net/20161124103238006?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /><br /></span></p>
<span style="font-size:18px;">       许多WebRTC应用只演示了浏览器间的通信，但是通过网关服务器可以实现WebRTC与<a href="http://en.wikipedia.org/wiki/Public_switched_telephone_network" title="Wikipedia article about the Public Switched Telephone Network" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><span style="color:#ff0000;">telephones</span></a>（别名<a href="https://en.wikipedia.org/wiki/Public_switched_telephone_network" title="Wikipedia: Public Switched Telephone Network" style="color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">PSTN</a>）和<a href="http://en.wikipedia.org/wiki/Voice_over_IP" title="Wikipedia article about Voice Over IP" style="color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">VOIP</a>系统直接的通信。</span><span style="font-size:18px;">2012年5月，Doubango
 Telecom开源了<a href="http://sipml5.org/" title="sipml5 site" style="color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">sipml5 SIP client</a>，该客户端基于WebRTC和WebSocket，能实现浏览器和IOS或Android应用之间的视频通话。</span><br /><h1><span style="font-size:24px;">十四.RTCDataChannel</span></h1>
<span style="font-size:18px;">       除了音频和视频，WebRTC支持其他类型数据的实时通信。</span><br /><span style="font-size:18px;">       TCDataChannel API支持p2p低延迟和高吞吐量的二进制数据流交换，这里有个例子：<a href="http://webrtc.github.io/samples/src/content/datachannel/datatransfer/" title="RTCDataChannel example" style="color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">http://webrtc.github.io/samples/src/content/datachannel/datatransfer</a></span><br /><span style="font-size:18px;">       很多领域都潜在地使用到了这个API，比如：</span><br /><span style="font-size:18px;">1.游戏</span><br /><span style="font-size:18px;">2.远程桌面应用</span><br /><span style="font-size:18px;">3.实时文字聊天</span><br /><span style="font-size:18px;">4.文件传输</span><br /><span style="font-size:18px;">5.分散网络</span><br /><span style="font-size:18px;">       充分利用了RTCPeerConnection的多个特性，能实现强大而灵活的p2p通信。</span><br /><span style="font-size:18px;">1.利用RTCPeerConnection进行会话设置。</span><br /><span style="font-size:18px;">2.通过优先级设置多个同步的channel。</span><br /><span style="font-size:18px;">3.可靠和非可靠的语义传递。</span><br /><span style="font-size:18px;">4.内建立安全的DTLS和拥塞控制。</span><br /><span style="font-size:18px;">5.能用于音视频或其他方面</span><br /><span style="font-size:18px;">TCDataChannel API语法与WebSocket类似，包括send()方法和message事件。</span><br /><pre class="cpp">var pc = new webkitRTCPeerConnection(servers,
  {optional: [{RtpDataChannels: true}]});

pc.ondatachannel = function(event) {
  receiveChannel = event.channel;
  receiveChannel.onmessage = function(event){
    document.querySelector("div#receive").innerHTML = event.data;
  };
};

sendChannel = pc.createDataChannel("sendDataChannel", {reliable: false});

document.querySelector("button#send").onclick = function (){
  var data = document.querySelector("textarea#send").value;
  sendChannel.send(data);
};</pre><span style="font-size:18px;">       因为是浏览器间的直接通信，所以RTCDataChannel要比WebSocket快得多，即使通信用到了中继服务器。</span><br /><span style="font-size:18px;">       RTCDataChannel可用于Chrome、Opera和Firefox。</span><span style="font-size:18px;">出色的<a href="http://www.cubeslam.com/" title="Cube Slam game" style="color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">Cube
 Slam</a>游戏使用TCDataChannel API来交换游戏状态：是敌还是友！</span><span style="font-size:18px;"><a href="http://www.sharefest.me/" title="Sharefest file sharing app" style="color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">Sharefest</a>演示了通过RTCDataChannel分享文件，<a href="https://peercdn.com/" title="peerCDN site" style="color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">peerCDN</a>提供了WebRTC如何实现p2p内容分发的一种思路。</span><br /><p><span style="font-size:18px;">       更多关于RTCDataChannel的信息，可以参考IETF的</span><a href="http://tools.ietf.org/html/draft-jesup-rtcweb-data-protocol-00" title="IETF Data Channel draft specification" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><span style="color:#ff0000;">draft
 protocol spec</span></a><span style="color:rgb(85,85,85);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">。</span></p>
<h1><span style="color:rgb(85,85,85);line-height:27px;"><span style="font-family:SimHei;font-size:24px;">十五.安全</span></span></h1>
<p><span style="font-size:18px;">       实时通信应用或插件会在许多方面忽视了安全性：</span></p>
<span style="font-size:18px;">1.浏览器之间、浏览器与服务器之间的音视频或其他数据没有加密。</span><br /><span style="font-size:18px;">2.应用在用户没有察觉的情况下录制和分发音视频。</span><br /><span style="font-size:18px;">3.恶意软件或病毒可能入侵了正常的插件或应用。</span><br /><span style="font-size:18px;">       WebRTC的许多特性可以避免这些问题：</span><br /><span style="font-size:18px;">1.WebRTC采用类似<a href="http://en.wikipedia.org/wiki/Datagram_Transport_Layer_Security" title="Wikipedia article about Datagram Transport Layer Security" style="color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">DTLS</a>和<a href="http://en.wikipedia.org/wiki/Secure_Real-time_Transport_Protocol" title="Wikipedia article about Secure Real-time Transport Protocol" style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;"><span style="color:#ff0000;">SRTP</span></a>的安全协议。</span><br /><span style="font-size:18px;">2.所有的WebRTC组件强制加密，包括信令机制。</span><br /><span style="font-size:18px;">3.WebRTC不是插件：它的组件运行于浏览器沙盒，不是独立的一个进程，这些组件不需要单独安装，且随着浏览器更新。</span><br /><span style="font-size:18px;">4.摄像头和麦克风的访问必须经过明确准许，当摄像头和麦克风运行时，界面上会清楚的显示出来。</span><br /><p><span style="font-size:18px;">       关于流媒体安全的讨论超出了本文的范畴。更多信息可参考IETF的<a href="http://www.ietf.org/proceedings/82/slides/rtcweb-13.pdf" title="Slides for IETF Proposed WebRTC Security Architecture" style="color:rgb(240,69,48);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:18px;line-height:27px;">WebRTC
 Security Architecture</a><span style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;color:#555555;"><span style="line-height:27px;">。<br /></span></span></span></p>
<p><span style="font-size:18px;"><span style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;color:#555555;"><span style="line-height:27px;"><br /></span></span></span></p>
<p><span style="font-size:18px;"><span style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;color:#555555;"><span style="line-height:27px;">原文链接：<a href="https://www.html5rocks.com/en/tutorials/webrtc/basics/">https://www.html5rocks.com/en/tutorials/webrtc/basics/</a></span></span></span></p>
<img src="http://img.blog.csdn.net/20161124104746967" alt="" /><br /><br /><br /><br /><p><br /></p>
                </div>
                    </div>
    </article>
      <div class="readall_box csdn-tracking-statistics tracking-click" data-mod="popu_376">
          <div class="read_more_mask"></div>
          <a class="btn btn-large btn-gray-fred read_more_btn" target="_self">阅读全文</a>
      </div>
      <div class="article_copyright">
         
                    版权声明：本文为灿哥哥http://blog.csdn.net/caoshangpa原创文章，转载请标明出处。             http://blog.csdn.net/caoshangpa/article/details/53306992              </div>
      <ul class="article_collect clearfix csdn-tracking-statistics tracking-click"  data-mod="popu_378">
          <li class="tit">本文已收录于以下专栏：</li>
<!--          [startarticlecolumns]-->
                                      <li><a href="//blog.csdn.net/column/details/14158.html" target="_blank">WebRTC学习</a></li>
                      <!--          [endarticlecolumns]-->
      </ul>
      <div class="comment_box clearfix" id="comments">
          <div id="comment_form">
              <div id="commentsbmitarear">
                              </div>
          </div>
      </div>
      <div class="comment_li_outbox">
          <div id="comment_list"></div>
      </div>

      <div class="more_comment">
          <div id="comment_bar" class="trackgin-ad" data-mod="popu_385"></div>
      </div>

      <!-- <h3 class="recommend_tit" id="related">相关文章推荐</h3> -->
      <div class="recommend_list clearfix" id="rasss">
                                          <dl class="clearfix csdn-tracking-statistics recommend_article" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
                <a href="http://blog.csdn.net/u010657219/article/details/54930821"  target="_blank" strategy="BlogCommendFromBaidu_0">
                    <dd>
                        <h2>WebRtc建立P2P链接的总体流程</h2>
                        <div class="summary">
                            初步介绍了webrtc建立p2p链接的大致流程！                        </div>

                        <ul>
                            <li class="avatar_img"><img src="//avatar.csdn.net/9/4/1/3_u010657219.jpg" alt="u010657219" title="u010657219"></li>
                            <li class="user_name">u010657219</li>
                            <li class="time">2017年02月08日 18:47</li>
                            <li class="visited_num"><i class="icon iconfont icon-read"></i><span>3972</span></li>
                        </ul>
                    </dd>
                </a>
            </dl>
                                                    <dl class="clearfix csdn-tracking-statistics recommend_article" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
                <a href="http://blog.csdn.net/swt198852/article/details/8138704"  target="_blank" strategy="BlogCommendFromBaidu_1">
                    <dd>
                        <h2>WEBRTC</h2>
                        <div class="summary">
                            WebRTC
目录
简介

架构

1.    
WebRTC架构组件介绍 
2.    
Network Stream API 
3.    
RTCPeerConnectio...                        </div>

                        <ul>
                            <li class="avatar_img"><img src="//avatar.csdn.net/1/D/D/3_swt198852.jpg" alt="swt198852" title="swt198852"></li>
                            <li class="user_name">swt198852</li>
                            <li class="time">2012年11月01日 22:08</li>
                            <li class="visited_num"><i class="icon iconfont icon-read"></i><span>6237</span></li>
                        </ul>
                    </dd>
                </a>
            </dl>
                                          <dl class="">
            <script>
            (function() {
              var s = "_" + Math.random().toString(36).slice(2);
              document.write('<div id="' + s + '"></div>');
              (window.slotbydup=window.slotbydup || []).push({
                id: '4765209',
                container: s,
                size: '808,120',
                display: 'inlay-fix'
              });
            })();
            </script>
          </dl>
                                        <dl class="clearfix csdn-tracking-statistics recommend_article" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
                <a href="http://blog.csdn.net/Explorer_day/article/details/55251495"  target="_blank" strategy="BlogCommendFromBaidu_2">
                    <dd>
                        <h2>WebRTC详解</h2>
                        <div class="summary">
                            1、WebRTC目的

WebRTC（Web Real-Time Communication）项目的最终目的主要是让Web开发者能够基于浏览器（Chrome\FireFox\...）
轻易快捷开发出丰...                        </div>

                        <ul>
                            <li class="avatar_img"><img src="//avatar.csdn.net/8/2/5/3_explorer_day.jpg" alt="Explorer_day" title="Explorer_day"></li>
                            <li class="user_name">Explorer_day</li>
                            <li class="time">2017年02月16日 09:27</li>
                            <li class="visited_num"><i class="icon iconfont icon-read"></i><span>1854</span></li>
                        </ul>
                    </dd>
                </a>
            </dl>
                                                    <dl class="clearfix csdn-tracking-statistics recommend_article" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
                <a href="http://blog.csdn.net/fireroll/article/details/44672103"  target="_blank" strategy="BlogCommendFromBaidu_3">
                    <dd>
                        <h2>WebRTC的google官方入门教程</h2>
                        <div class="summary">
                            一、前言
WebRTC可以实现基于浏览器的实时通信。
这个教程演示了如何建立一个视频和文本聊天应用。
关于WebRTC的更多资料，可以看在HTML5 Rock上的
《Getting start...                        </div>

                        <ul>
                            <li class="avatar_img"><img src="//avatar.csdn.net/1/3/0/3_fireroll.jpg" alt="fireroll" title="fireroll"></li>
                            <li class="user_name">fireroll</li>
                            <li class="time">2015年03月27日 10:07</li>
                            <li class="visited_num"><i class="icon iconfont icon-read"></i><span>5305</span></li>
                        </ul>
                    </dd>
                </a>
            </dl>
                                                    <dl class="clearfix csdn-tracking-statistics downloadElement" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
                <a class="clearfix" href="https://download.csdn.net/download/qq_35054800/10135721" target="_blank" strategy="BlogCommendFromBaidu_4">
                    <dd class="floatL">
                        <div class="summary">
                            <h2>WebrtcDemo</h2>
                            <div class="summary">
                                <ul>
                                    <li class="time">2017年11月28日 11:45</li>
                                    <li class="visited_num fileSize">2.41MB</li>
                                    <li class="download_btn">下载</li>
                                </ul>
                            </div>
                        </div>
                    </dd>
                    <dt class="floatR"><img class="maxwidth" src="http://csdnimg.cn/release/download/old_static/images/minetype/zip.svg" alt="" title=""/></dt>
                </a>
            </dl>
                                                    <dl class="clearfix csdn-tracking-statistics recommend_article" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
                <a href="http://blog.csdn.net/languobeibei/article/details/77193883"  target="_blank" strategy="BlogCommendFromBaidu_5">
                    <dd>
                        <h2>基于Webrtc的多人视频会议的简单实现</h2>
                        <div class="summary">
                            通过重写WEBRTC传输模块来实现一个简单的视频会议，效果如下图：



说明：

1、画面1、2、3都是其他手机传过来的图像，局域网内有点点卡顿，同时软解3路数据你懂的。

2、声音...                        </div>

                        <ul>
                            <li class="avatar_img"><img src="//avatar.csdn.net/D/1/5/3_languobeibei.jpg" alt="languobeibei" title="languobeibei"></li>
                            <li class="user_name">languobeibei</li>
                            <li class="time">2017年08月15日 17:40</li>
                            <li class="visited_num"><i class="icon iconfont icon-read"></i><span>2184</span></li>
                        </ul>
                    </dd>
                </a>
            </dl>
                                                    <dl class="clearfix csdn-tracking-statistics recommend_article" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
                <a href="http://blog.csdn.net/youmingyu/article/details/53192714"  target="_blank" strategy="BlogCommendFromBaidu_6">
                    <dd>
                        <h2>WebRTC 的 Android 2 Android 实现</h2>
                        <div class="summary">
                            公司让做一个小项目作为入职测试，简单的说就是实现WebRTC的android端互连。boss给提供了一个开源项目作为参考，这个项目是WebRTC的android客户端，可以实现android端连接PC...                        </div>

                        <ul>
                            <li class="avatar_img"><img src="//avatar.csdn.net/9/2/0/3_youmingyu.jpg" alt="youmingyu" title="youmingyu"></li>
                            <li class="user_name">youmingyu</li>
                            <li class="time">2016年11月17日 16:12</li>
                            <li class="visited_num"><i class="icon iconfont icon-read"></i><span>17683</span></li>
                        </ul>
                    </dd>
                </a>
            </dl>
                                                    <dl class="clearfix csdn-tracking-statistics recommend_article" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
                <a href="http://blog.csdn.net/xiaoluer/article/details/79088416"  target="_blank" strategy="BlogCommendFromBaidu_7">
                    <dd>
                        <h2>三个基于WebRTC开源MCU框架的横向对比</h2>
                        <div class="summary">
                            1. licode
官网地址：
http://lynckia.com/licode/index.html

官方demo地址：
https://chotis2.dit.upm.es/

...                        </div>

                        <ul>
                            <li class="avatar_img"><img src="//avatar.csdn.net/8/C/6/3_xiaoluer.jpg" alt="xiaoluer" title="xiaoluer"></li>
                            <li class="user_name">xiaoluer</li>
                            <li class="time">2018年01月17日 18:19</li>
                            <li class="visited_num"><i class="icon iconfont icon-read"></i><span>561</span></li>
                        </ul>
                    </dd>
                </a>
            </dl>
                                                    <dl class="clearfix csdn-tracking-statistics recommend_article" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
                <a href="http://blog.csdn.net/yangzhenping/article/details/51276320"  target="_blank" strategy="BlogCommendFromBaidu_8">
                    <dd>
                        <h2>编译最新版webrtc源码和编译好的整个项目10多个G【分享】</h2>
                        <div class="summary">
                            编译最新版webrtc源码和编译好的整个项目【分享】

参考https://webrtc.org/native-code/development/编译最新版webrtc源码...                        </div>

                        <ul>
                            <li class="avatar_img"><img src="//avatar.csdn.net/F/E/0/3_yangzhenping.jpg" alt="yangzhenping" title="yangzhenping"></li>
                            <li class="user_name">yangzhenping</li>
                            <li class="time">2016年04月28日 17:40</li>
                            <li class="visited_num"><i class="icon iconfont icon-read"></i><span>22872</span></li>
                        </ul>
                    </dd>
                </a>
            </dl>
                                                    <dl class="clearfix csdn-tracking-statistics recommend_article" data-mod="popu_387" data-poputype="feed"  data-feed-show="false"  data-dsm="post">
                <a href="http://blog.csdn.net/future_todo/article/details/52689420"  target="_blank" strategy="BlogCommendFromBaidu_9">
                    <dd>
                        <h2>WebRTC1-原理探究</h2>
                        <div class="summary">
                            1.抛砖引玉WebRTC (Web Real-Time Communications) 是一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Pe...                        </div>

                        <ul>
                            <li class="avatar_img"><img src="//avatar.csdn.net/4/F/8/3_future_todo.jpg" alt="future_todo" title="future_todo"></li>
                            <li class="user_name">future_todo</li>
                            <li class="time">2016年09月28日 12:26</li>
                            <li class="visited_num"><i class="icon iconfont icon-read"></i><span>2198</span></li>
                        </ul>
                    </dd>
                </a>
            </dl>
                              </div>
  </main>
<aside>
    <div class="right_box user_info">
    <dl class="inf_bar clearfix">
        <dt class="csdn-tracking-statistics tracking-click" data-mod="popu_381">
                <a href="//blog.csdn.net/caoshangpa" target="_blank">
                    <img src="//avatar.csdn.net/8/E/A/3_caoshangpa.jpg" class="avatar_pic">
        </a>
      </dt><dd>
            <h3 class="csdn-tracking-statistics tracking-click"  data-mod="popu_380"><a href="//blog.csdn.net/caoshangpa" target="_blank" id="uid">caoshangpa</a></h3>
            <div class="medals" title="">
                      </div>
                    </dd>
    </dl>
    <div class="inf_number_box clearfix">
        <dl title="211">
            <dt>原创</dt>
            <dd>211</dd>
        </dl>
        <dl title="390">
            <dt>粉丝</dt>
            <dd id='fan'>390</dd>
        </dl>
        <dl title="1793">
            <dt>喜欢</dt>
            <dd>1793</dd>
        </dl>
        <dl title="326">
          <dt>评论</dt>
          <dd>326</dd>
        </dl>
    </div>

</div>
<div class="interflow clearfix">
      <div class="badge gradeAndbadge">
        <div>
                        <img src='//csdnimg.cn/jifen/images/xunzhang/xunzhang/zhuanlandaren.png' alt='专栏达人'>
                                    <img src='//csdnimg.cn/jifen/images/xunzhang/xunzhang/chizhiyiheng.png' alt='持之以恒'>
                                            </div>
    </div>
      <div class="grade gradeAndbadge gradewidths">
      <span>等级：</span>
      <div>
        <a href="http://blog.csdn.net/home/help.html#level" title="7级,点击查看等级说明" target="_blank">
          <img class="grade-img" src="//csdnimg.cn/jifen/images/xunzhang/jianzhang/blog7.png" alt="7级,点击查看等级说明">
        </a>
      </div>
    </div>
    <div class="gradeAndbadge gradewidths" title="654987">
        <span>访问量：</span>
        <span class="num odd-overhidden">65万+</span>
    </div>

    <div class="gradeAndbadge gradewidths" title="11096">
      <span>积分：</span>
      <span  class="num odd-overhidden">1万+</span>
    </div>
    <div class="gradeAndbadge gradewidths" title="1757">
        <span>排名：</span>
        <span class="num odd-overhidden">1757</span>
    </div>

</div>
<script type="text/javascript">
  // 判断并设置用户名位置，没有博客专家与关注按钮时，用户名居中
  $medals_children = $('.medals').children().length;
  $span_add_follow = $('#span_add_follow').length;
  if($medals_children === 0 && $span_add_follow === 0){
    $('.inf_bar dd').css('vertical-align','10px')
  }
</script>          <div class="extension_other csdn-tracking-statistics tracking-click" data-mod="popu_389">
          <!--u3032528-->
        <div class="flashrecommend">
                        <script type="text/javascript" src="//cee1.iteye.com/bwocoltly.js"></script>
                    </div>
      </div>
            <div class="writings">
      <div class="public_signal clearfix">
        <h3>他的最新文章</h3>
        <a href="//blog.csdn.net/caoshangpa" target="_blank" class="more"><span>更多文章</span></a>
      </div>
        <ul class="inf_list clearfix csdn-tracking-statistics tracking-click" data-mod="popu_382">
                        <li class="clearfix">
                <a href="http://blog.csdn.net/caoshangpa/article/details/79554102" target="_blank">CDN的原理以及其中的一些技术</a>
            </li>
                        <li class="clearfix">
                <a href="http://blog.csdn.net/caoshangpa/article/details/79553936" target="_blank">什么是CDN及CDN加速原理</a>
            </li>
                        <li class="clearfix">
                <a href="http://blog.csdn.net/caoshangpa/article/details/79543916" target="_blank">RTMP和HLS的比较</a>
            </li>
                        <li class="clearfix">
                <a href="http://blog.csdn.net/caoshangpa/article/details/79543846" target="_blank">深入浅出看流媒体前世今生</a>
            </li>
                        <li class="clearfix">
                <a href="http://blog.csdn.net/caoshangpa/article/details/79536005" target="_blank">Effective C++笔记之七：为多态基类声明virtual析构函数</a>
            </li>
                    </ul>
    </div>
                <div class="user-hotArticle sort ClassSort">
            <h3>文章分类</h3>
            <ul class="hotArticle-list sort-list ClassSort-list">
                                    <li class="clearfix">
                        <a href="//blog.csdn.net/caoshangpa/article/category/6129124" class="odd-overhidden floatL">Qt</a>
                        <div class="read list-left floatR"><span>144篇</span></div>
                    </li>
                                    <li class="clearfix">
                        <a href="//blog.csdn.net/caoshangpa/article/category/6129125" class="odd-overhidden floatL">Python</a>
                        <div class="read list-left floatR"><span>1篇</span></div>
                    </li>
                                    <li class="clearfix">
                        <a href="//blog.csdn.net/caoshangpa/article/category/6129126" class="odd-overhidden floatL">3D</a>
                        <div class="read list-left floatR"><span>11篇</span></div>
                    </li>
                                    <li class="clearfix">
                        <a href="//blog.csdn.net/caoshangpa/article/category/6142869" class="odd-overhidden floatL">other</a>
                        <div class="read list-left floatR"><span>70篇</span></div>
                    </li>
                                    <li class="clearfix">
                        <a href="//blog.csdn.net/caoshangpa/article/category/6452246" class="odd-overhidden floatL">设计模式</a>
                        <div class="read list-left floatR"><span>24篇</span></div>
                    </li>
                                    <li class="clearfix">
                        <a href="//blog.csdn.net/caoshangpa/article/category/6458511" class="odd-overhidden floatL">JavaScript</a>
                        <div class="read list-left floatR"><span>1篇</span></div>
                    </li>
                                    <li class="clearfix">
                        <a href="//blog.csdn.net/caoshangpa/article/category/6460372" class="odd-overhidden floatL">C/C++</a>
                        <div class="read list-left floatR"><span>30篇</span></div>
                    </li>
                                    <li class="clearfix">
                        <a href="//blog.csdn.net/caoshangpa/article/category/6460835" class="odd-overhidden floatL">libevent</a>
                        <div class="read list-left floatR"><span>5篇</span></div>
                    </li>
                                    <li class="clearfix">
                        <a href="//blog.csdn.net/caoshangpa/article/category/7351350" class="odd-overhidden floatL">leveldb</a>
                        <div class="read list-left floatR"><span>16篇</span></div>
                    </li>
                                    <li class="clearfix">
                        <a href="//blog.csdn.net/caoshangpa/article/category/6460841" class="odd-overhidden floatL">学习现代3D图形编程</a>
                        <div class="read list-left floatR"><span>4篇</span></div>
                    </li>
                                    <li class="clearfix">
                        <a href="//blog.csdn.net/caoshangpa/article/category/6465272" class="odd-overhidden floatL">C++11</a>
                        <div class="read list-left floatR"><span>18篇</span></div>
                    </li>
                                    <li class="clearfix">
                        <a href="//blog.csdn.net/caoshangpa/article/category/6466332" class="odd-overhidden floatL">PhotoShop</a>
                        <div class="read list-left floatR"><span>2篇</span></div>
                    </li>
                                    <li class="clearfix">
                        <a href="//blog.csdn.net/caoshangpa/article/category/6472774" class="odd-overhidden floatL">流媒体</a>
                        <div class="read list-left floatR"><span>57篇</span></div>
                    </li>
                                    <li class="clearfix">
                        <a href="//blog.csdn.net/caoshangpa/article/category/6515364" class="odd-overhidden floatL">优秀开源项目</a>
                        <div class="read list-left floatR"><span>5篇</span></div>
                    </li>
                                    <li class="clearfix">
                        <a href="//blog.csdn.net/caoshangpa/article/category/6533427" class="odd-overhidden floatL">WebRTC</a>
                        <div class="read list-left floatR"><span>11篇</span></div>
                    </li>
                                    <li class="clearfix">
                        <a href="//blog.csdn.net/caoshangpa/article/category/7328401" class="odd-overhidden floatL">我的炒股</a>
                        <div class="read list-left floatR"><span>1篇</span></div>
                    </li>
                                    <li class="clearfix">
                        <a href="//blog.csdn.net/caoshangpa/article/category/7341118" class="odd-overhidden floatL">算法与数据结构</a>
                        <div class="read list-left floatR"><span>5篇</span></div>
                    </li>
                                    <li class="clearfix">
                        <a href="//blog.csdn.net/caoshangpa/article/category/7427512" class="odd-overhidden floatL">笔试题</a>
                        <div class="read list-left floatR"><span>6篇</span></div>
                    </li>
                                    <li class="clearfix">
                        <a href="//blog.csdn.net/caoshangpa/article/category/7438478" class="odd-overhidden floatL">Boost.Asio C++ 网络编程</a>
                        <div class="read list-left floatR"><span>11篇</span></div>
                    </li>
                                    <li class="clearfix">
                        <a href="//blog.csdn.net/caoshangpa/article/category/7477279" class="odd-overhidden floatL">软件架构</a>
                        <div class="read list-left floatR"><span>8篇</span></div>
                    </li>
                                    <li class="clearfix">
                        <a href="//blog.csdn.net/caoshangpa/article/category/7478576" class="odd-overhidden floatL">Effective C++笔记</a>
                        <div class="read list-left floatR"><span>7篇</span></div>
                    </li>
                                    <li class="clearfix">
                        <a href="//blog.csdn.net/caoshangpa/article/category/7489748" class="odd-overhidden floatL">视频直播技术详解</a>
                        <div class="read list-left floatR"><span>8篇</span></div>
                    </li>
                                    <li class="clearfix">
                        <a href="//blog.csdn.net/caoshangpa/article/category/7496323" class="odd-overhidden floatL">Simple-RTMP-Server</a>
                        <div class="read list-left floatR"><span>3篇</span></div>
                    </li>
                            </ul>
            <div class="unfold-btn">
              <span>展开</span><i class="icon iconfont icon-xiajiantou"></i>
            </div>
        </div>
    <!--    [StartShowSelfColumn]-->
            <div class="host-column">
            <h3>博主专栏</h3>
            <ul class="column-list csdn-tracking-statistics tracking-click" data-mod="popu_520" >
<!--                [StartSelfColumn]-->
                                    <li class="clearfix">
                        <div class="img list-left">
                            <a href="//blog.csdn.net/column/details/14158.html">
                                <img src="http://img.blog.csdn.net/20170106094248975" alt="">
                                <div>11 篇</div>
                            </a>
                        </div>
                        <div class="content list-left">
                            <h4 class="title"><a href="//blog.csdn.net/column/details/14158.html">WebRTC学习</a></h4>
                            <div class="read list-left"><i class="icon iconfont icon-read"></i><span>34488</span></div>
                        </div>
                    </li>
                <!--                [EndSelfColumn]-->
            </ul>
            <div class="unfold-btn">
                <span>展开</span><i class="icon iconfont icon-xiajiantou"></i>
            </div>
        </div>
    <!--    [EndShowSelfColumn]-->
            <div class="user-hotArticle sort timeSort">
          <h3>文章存档</h3>
          <ul class="hotArticle-list timeSort-list">
                            <li class="clearfix">
                  <a href="//blog.csdn.net/caoshangpa/article/month/2018/03" class="odd-overhidden floatL">2018年3月</a>
                  <div class="read list-left floatR"><span>27篇</span></div>
                </li>
                            <li class="clearfix">
                  <a href="//blog.csdn.net/caoshangpa/article/month/2018/02" class="odd-overhidden floatL">2018年2月</a>
                  <div class="read list-left floatR"><span>14篇</span></div>
                </li>
                            <li class="clearfix">
                  <a href="//blog.csdn.net/caoshangpa/article/month/2018/01" class="odd-overhidden floatL">2018年1月</a>
                  <div class="read list-left floatR"><span>31篇</span></div>
                </li>
                            <li class="clearfix">
                  <a href="//blog.csdn.net/caoshangpa/article/month/2017/12" class="odd-overhidden floatL">2017年12月</a>
                  <div class="read list-left floatR"><span>26篇</span></div>
                </li>
                            <li class="clearfix">
                  <a href="//blog.csdn.net/caoshangpa/article/month/2017/11" class="odd-overhidden floatL">2017年11月</a>
                  <div class="read list-left floatR"><span>76篇</span></div>
                </li>
                            <li class="clearfix">
                  <a href="//blog.csdn.net/caoshangpa/article/month/2017/09" class="odd-overhidden floatL">2017年9月</a>
                  <div class="read list-left floatR"><span>2篇</span></div>
                </li>
                            <li class="clearfix">
                  <a href="//blog.csdn.net/caoshangpa/article/month/2017/08" class="odd-overhidden floatL">2017年8月</a>
                  <div class="read list-left floatR"><span>4篇</span></div>
                </li>
                            <li class="clearfix">
                  <a href="//blog.csdn.net/caoshangpa/article/month/2017/07" class="odd-overhidden floatL">2017年7月</a>
                  <div class="read list-left floatR"><span>6篇</span></div>
                </li>
                            <li class="clearfix">
                  <a href="//blog.csdn.net/caoshangpa/article/month/2017/06" class="odd-overhidden floatL">2017年6月</a>
                  <div class="read list-left floatR"><span>8篇</span></div>
                </li>
                            <li class="clearfix">
                  <a href="//blog.csdn.net/caoshangpa/article/month/2017/05" class="odd-overhidden floatL">2017年5月</a>
                  <div class="read list-left floatR"><span>6篇</span></div>
                </li>
                            <li class="clearfix">
                  <a href="//blog.csdn.net/caoshangpa/article/month/2017/04" class="odd-overhidden floatL">2017年4月</a>
                  <div class="read list-left floatR"><span>3篇</span></div>
                </li>
                            <li class="clearfix">
                  <a href="//blog.csdn.net/caoshangpa/article/month/2017/03" class="odd-overhidden floatL">2017年3月</a>
                  <div class="read list-left floatR"><span>8篇</span></div>
                </li>
                            <li class="clearfix">
                  <a href="//blog.csdn.net/caoshangpa/article/month/2017/01" class="odd-overhidden floatL">2017年1月</a>
                  <div class="read list-left floatR"><span>11篇</span></div>
                </li>
                            <li class="clearfix">
                  <a href="//blog.csdn.net/caoshangpa/article/month/2016/12" class="odd-overhidden floatL">2016年12月</a>
                  <div class="read list-left floatR"><span>22篇</span></div>
                </li>
                            <li class="clearfix">
                  <a href="//blog.csdn.net/caoshangpa/article/month/2016/11" class="odd-overhidden floatL">2016年11月</a>
                  <div class="read list-left floatR"><span>45篇</span></div>
                </li>
                            <li class="clearfix">
                  <a href="//blog.csdn.net/caoshangpa/article/month/2016/10" class="odd-overhidden floatL">2016年10月</a>
                  <div class="read list-left floatR"><span>74篇</span></div>
                </li>
                            <li class="clearfix">
                  <a href="//blog.csdn.net/caoshangpa/article/month/2016/09" class="odd-overhidden floatL">2016年9月</a>
                  <div class="read list-left floatR"><span>6篇</span></div>
                </li>
                            <li class="clearfix">
                  <a href="//blog.csdn.net/caoshangpa/article/month/2016/08" class="odd-overhidden floatL">2016年8月</a>
                  <div class="read list-left floatR"><span>6篇</span></div>
                </li>
                            <li class="clearfix">
                  <a href="//blog.csdn.net/caoshangpa/article/month/2016/07" class="odd-overhidden floatL">2016年7月</a>
                  <div class="read list-left floatR"><span>3篇</span></div>
                </li>
                            <li class="clearfix">
                  <a href="//blog.csdn.net/caoshangpa/article/month/2016/06" class="odd-overhidden floatL">2016年6月</a>
                  <div class="read list-left floatR"><span>4篇</span></div>
                </li>
                            <li class="clearfix">
                  <a href="//blog.csdn.net/caoshangpa/article/month/2016/05" class="odd-overhidden floatL">2016年5月</a>
                  <div class="read list-left floatR"><span>26篇</span></div>
                </li>
                            <li class="clearfix">
                  <a href="//blog.csdn.net/caoshangpa/article/month/2016/04" class="odd-overhidden floatL">2016年4月</a>
                  <div class="read list-left floatR"><span>30篇</span></div>
                </li>
                            <li class="clearfix">
                  <a href="//blog.csdn.net/caoshangpa/article/month/2016/03" class="odd-overhidden floatL">2016年3月</a>
                  <div class="read list-left floatR"><span>10篇</span></div>
                </li>
                      </ul>
          <div class="unfold-btn">
            <span>展开</span><i class="icon iconfont icon-xiajiantou"></i>
          </div>
        </div>
            <div class="user-hotArticle">
        <h3>他的热门文章</h3>
        <ul class="hotArticle-list csdn-tracking-statistics tracking-click" data-mod="popu_521">
<!--        [StartHotArticles]-->
                            <li>
                    <a href="http://blog.csdn.net/caoshangpa/article/details/52954552">JWPlayer 7的正确使用方法及Flash plugin failed to load解决方法</a>
                    <div class="read list-left"><i class="icon iconfont icon-read"></i><span>22225</span></div>
                </li>
                            <li>
                    <a href="http://blog.csdn.net/caoshangpa/article/details/51036267">Qt生成随机数的方法</a>
                    <div class="read list-left"><i class="icon iconfont icon-read"></i><span>18327</span></div>
                </li>
                            <li>
                    <a href="http://blog.csdn.net/caoshangpa/article/details/51530685">TCP、UDP数据包大小的限制</a>
                    <div class="read list-left"><i class="icon iconfont icon-read"></i><span>17108</span></div>
                </li>
                            <li>
                    <a href="http://blog.csdn.net/caoshangpa/article/details/51104022">Qt C++定义全局变量的两种方式</a>
                    <div class="read list-left"><i class="icon iconfont icon-read"></i><span>13457</span></div>
                </li>
                            <li>
                    <a href="http://blog.csdn.net/caoshangpa/article/details/53156061">使用VLC浏览器插件播放RTSP流</a>
                    <div class="read list-left"><i class="icon iconfont icon-read"></i><span>11524</span></div>
                </li>
                            <li>
                    <a href="http://blog.csdn.net/caoshangpa/article/details/50915005">Qt串口通信接收数据不完整的解决方法</a>
                    <div class="read list-left"><i class="icon iconfont icon-read"></i><span>11280</span></div>
                </li>
                            <li>
                    <a href="http://blog.csdn.net/caoshangpa/article/details/53306992">WebRTC学习之一：开篇</a>
                    <div class="read list-left"><i class="icon iconfont icon-read"></i><span>9998</span></div>
                </li>
                            <li>
                    <a href="http://blog.csdn.net/caoshangpa/article/details/53690612">使用Qt5.7.0 VS2015版本生成兼容XP的可执行程序</a>
                    <div class="read list-left"><i class="icon iconfont icon-read"></i><span>9772</span></div>
                </li>
                            <li>
                    <a href="http://blog.csdn.net/caoshangpa/article/details/50893772">Qt中如何使用Sleep函数</a>
                    <div class="read list-left"><i class="icon iconfont icon-read"></i><span>9041</span></div>
                </li>
                            <li>
                    <a href="http://blog.csdn.net/caoshangpa/article/details/52934927">xampp的安装及使用</a>
                    <div class="read list-left"><i class="icon iconfont icon-read"></i><span>8998</span></div>
                </li>
            <!--        [EndHotArticles]-->
        </ul>
    </div>
    
<!--    [startcustom]-->
    <!--    [endcustom]-->
  <div class="fixRight_box" style="height:256px">
    <div class="fixRight">
                    <!--u3163270-->
                        <script type="text/javascript" src="//cee1.iteye.com/avneunkwb.js"></script>
                          <div class="persion_article"></div>
    </div>
  </div>
</aside>
</div>

<div class="left_fixed">
    <div class="left_show_button">
        <span>
          <i class="icon iconfont icon-youjiantou"></i>
        </span>
    </div>
    <ul class="left_menu" id="share_box">
        <li>
            <button class="left-fixed-btn btn-like csdn-tracking-statistics tracking-click" data-mod="popu_373" target="_self" title="点赞">
                <a href="javascript:void(0);" class="iconbox border_red" ><i class="icon iconfont icon-dianzan"></i></a>
                <a class="txt" href="javascript:void(0);">11</a>
            </button>
        </li>
        <li id="blog_artical_directory">
            <button class="left-fixed-btn left_menu_btn csdn-tracking-statistics tracking-click" data-mod="popu_372" target="_self" title="目录">
                <a href="javascript:void(0);" class="iconbox border_black" ><i class="icon iconfont icon-mulu"></i></a>
            </button>
        </li>
        <li class="menu_con">
            <div class="list_father">
                <div class="arr_box">
                    <button class="btn-noborder arr-btn scroll-down  left_scroll_down"><i class="icon iconfont icon-xiajiantou"></i></button>
                    <button class="btn-noborder arr-btn scroll-up left_scroll_top"><i class="icon iconfont icon-shangjiantou"></i></button>
                </div>
                <div class="arr"></div>
                <div id="csdnBlogDir"></div>
            </div>
        </li>
        <!--        <li>-->
        <!--            <button class="left-fixed-btn btn-like tracking-ad" data-mod="popu_373" target="_self">-->
        <!--                <span class="iconbox border_red"><i class="icon iconfont icon-xihuan-"></i></span>-->
        <!--                <span class="txt">喜欢</span>-->
        <!--                <span class="untxt">取消喜欢</span>-->
        <!--            </button>-->
        <!--        </li>-->
        <li>
            <button class="left-fixed-btn csdn-tracking-statistics tracking-click" data-mod="popu_374"  id="com-quick-collect" target="_self" title="收藏">
                <a href="javascript:void(0);" class="iconbox border_purple" ><i class="icon iconfont icon-shoucang"></i></a>
            </button>
        </li>
        <li>
            <button class="left-fixed-btn btn-pinglun csdn-tracking-statistics tracking-click" data-mod="popu_544" title="评论">
                <a href="javascript:void(0);" class="iconbox border_purple" ><i class="icon iconfont icon-pinglun"></i></a>
            </button>
        </li>
        <li class="bdsharebuttonbox csdn-tracking-statistics tracking-click" data-mod="popu_172">
            <a class="bds_tsina outside left-fixed-btn" data-cmd="tsina" title="分享到新浪微博"></a>
            <span class="iconbox border_red2"><i class="icon iconfont icon-xinlang"></i></span>
        </li>
        <li class="bdsharebuttonbox csdn-tracking-statistics tracking-click" data-mod="popu_172">
            <a class="bds_weixin outside left-fixed-btn" data-cmd="weixin" title="分享到微信"></a>
            <span class="iconbox border_green"><i class="icon iconfont icon-weixin"></i></span>
        </li>
        <li class="bdsharebuttonbox csdn-tracking-statistics tracking-click" data-mod="popu_172">
            <a class="bds_qzone outside left-fixed-btn" data-cmd="qzone" title="分享到QQ空间"></a>
            <span class="iconbox border_blue"><i class="icon iconfont icon-QQ"></i></span>
        </li>
        <li id="share_box">
            
            <div class="bdsharebuttonbox csdn-tracking-statistics tracking-click" data-mod="popu_172">
                
                
                
            </div>
        </li>
    </ul>
</div>
<div id="pop_win"></div>
<div id="popup_mask"></div>
<div class="pop_CA_cover" ></div>
<div class="pop pop_CA" >
    <div class="CA_header">
        收藏助手
        <span class="cancel_icon"  id="fapancle" ></span>
    </div>
    <iframe src="" id="collectIframe" frameborder="0" width="100%" height="360"  scrolling="no" ></iframe>
</div>
<!--举报-->
<div id="report_dialog" style="top: 250px; left: 343.5px;"><div id="panel_report">
    <div class="panel_head">不良信息举报</div>
    <form method="post" id="frmReport" class="panel_body">
        <table border="0" cellpadding="0" cellspacing="4" class="pop_table">
            <tbody><tr><td colspan="2">您举报文章：<a href="http://blog.csdn.net/caoshangpa/article/details/53306992" target="_blank">WebRTC学习之一：开篇</a></td></tr>
            <tr>
                <th style="width:60px;">举报原因：</th>
                <td id="panel_reporttype">
                    <label><input type="radio" class="report_type" id="report_sex" name="report_type" value="1">色情</label>
                    <label><input type="radio" class="report_type" id="report_Politics" name="report_type" value="2">政治</label>
                    <label><input type="radio" class="report_type" id="report_copy" name="report_type" value="3">抄袭</label>
                    <label><input type="radio" class="report_type" id="report_ad" name="report_type" value="4">广告</label>
                    <label><input type="radio" class="report_type" id="report_want" name="report_type" value="5">招聘</label>
                    <label><input type="radio" class="report_type" id="report_call" name="report_type" value="6">骂人</label>
                    <br>
                    <label><input type="radio" class="report_type" id="report_other" name="report_type" value="7">其他</label>
                    <input type="text" name="report_other_content" id="report_other_content" maxlength="30" style="display: none;">
                </td>
            </tr>
            <tr id="panel_originalurl" style="display: none;">
                <th>原文地址：</th>
                <td>
                    <input id="originalurl" value="http://" name="originalurl" type="text" style="width: 90%;">
                </td>
            </tr>
            <tr>
                <th id="sp_reason">原因补充：</th>
                <td>
                    <textarea id="report_description" style="width: 300px;" rows="3" name="report_description"></textarea>
                    <p id="sp_n" style="color:#999;margin:0px;padding:0px;">(最多只允许输入30个字)</p>
                </td>
            </tr>
            <tr>
                <td></td>
                <td>
                    <input id="btnSubmitReport" name="submit" type="image" align="middle" class="btn_1" src="https://csdnimg.cn/release/phoenix/images/btn_submit.jpg">
                    <span style="padding-left:20px;"></span>
                    <img id="btnCloseReportDialog" src="https://csdnimg.cn/release/phoenix/images/btn_cancel.jpg" align="middle">
                    <div id="error" style="color: Red">
                    </div>
                </td>
            </tr>
            </tbody></table>
    </form>
</div>
    <script language="javascript" type="text/javascript">
        var isComment=0;
        //显示隐藏地址
        $(function () {
          console.log("version:phoenix");
            if(isComment){
                $("#report_description").attr("disabled",true);
                $("#sp_n").hide();
                $("#sp_reason").html("评论内容：");
            }
            $(".report_type").click(function () {
                $("#panel_originalurl,#report_other_content").hide();
                switch ($(this).val()) {
                    case '3':
                        $("#panel_originalurl").show();
                        $("#originalurl").focus();
                        break;
                    case '7':
                        if(isComment){
                            $("#report_other_content").show().focus();
                        }
                        break;
                }

            });

            $("#frmReport").submit(function () {
                if (!currentUserName) {

                    if (confirm("您的操作必须登录，是否登录？")) {
                        location.href = "//passport.csdn.net/account/login?from=" + encodeURIComponent(location.href);
                        return false;
                    }
                    return false;
                }

                var reportType = $("input[name=report_type]:checked").val();
                if(!reportType){
                    alert("请选择举报原因！");
                    return false;
                }
                var otherInfo = "";
                switch (reportType) {
                    case '3':
                        otherInfo = $("#originalurl").val();
                        if (otherInfo == ""||otherInfo=="http://") {
                            alert("举报抄袭必须提供原创文章地址！");
                            $("#originalurl").focus();
                            return false;
                        } else if(!checkeURL(otherInfo)) {
                            alert("请输入正确的原创文章地址！");
                            $("#originalurl").focus();
                            return false;
                        }
                        break;
                    case '7':
                        otherInfo = $("#report_other_content").val();
                        if (isComment && !otherInfo) {
                            alert("请填写举报的具体原因！");
                            $("#report_other_content").focus();
                            return false;
                        }
                        if(!isComment){
                            if(!$("#report_description").val()){
                                alert("请填写举报的具体原因！");
                                $("#report_description").focus();
                                return false;
                            }
                        }
                        break;
                }
                if(!isComment){
                    if($("#report_description").val().length>30){
                        alert("举报原因最多只允许输入30个字！");
                        return false;
                    }
                }
	            nowTime = {
		            year: new Date().getFullYear(),
		            month: parseInt(new Date().getMonth())+1,
		            day: new Date().getDate(),
		            hours: parseInt(new Date().getHours())+1,
		            minutes: parseInt(new Date().getMinutes())+1,
		            seconds: parseInt(new Date().getSeconds())+1
	            };
	            var data = {
		            articleId: fileName,
		            commentId: 0,
		            reportType: reportType,
		            originalurl: $("#originalurl").val(),
		            report_other_content: $("#report_other_content").val(),
		            report_description: $("#report_description").val(),
		            currentUserName: currentUserName,
		            updatetime: nowTime.year+'/'+nowTime.month+'/'+nowTime.day+' '+ nowTime.hours+':'+nowTime.minutes+':'+seconds,
		            blogUser: username
	            };
	            if(!isComment){//如果是举报文章
		            data.report_other_content = data.report_description;
		            // data.report_description = "1. 神经网络这是一个常见的神经网络的图：这是一个常见的三层神经网络的基本构成，Layer L1是输入层，Layer L2是隐含层";
	            }

	            $.post(blog_address + "/common/report?id="+fileName+"&t=2", data, function (data) {
		            if (data.result == 1){
			            SetError("感谢您的举报，我们会尽快审核！");
		            }else{
			            if (data.content) alert(data.content);
		            }

	            });
                return false;
            });

            $("#btnCloseReportDialog").click(function () {
                CloseDiv();
            });

        });

        //提示后关闭方法
        function SetError(error) {
            $("#btnCloseReportDialog").trigger("click");
            alert(error);
            CloseDiv();
        }

        //关闭方法
        function CloseDiv() {

            $.removeMask();
            $("#report_dialog").hide();
            return false;
        }

        //验证url
        function checkeURL(url){
            return /^http(s)?:\/\/([\w-]+\.)+[\w-]+/i.test(url);
        }
    </script>
</div>
<!--  fixme 后期清理掉  -->
<div id="a52b5334d" style="width: 1px; height: 1px; display: none;">
    <script id="adJs52b5334"></script>
    <script>document.getElementById("adJs52b5334").src = "https://ads.csdn.net/js/opt/52b5334.js?t=" + Math.random();</script>
</div>
<script>
    $(".MathJax").remove();
</script>
<script type="text/javascript" src="//static-blog.csdn.net/mdeditor/public/res/bower-libs/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<!-- <script type="text/javascript" src="https://passport.csdn.net/content/loginbox/login.js"></script> -->
<script>window._bd_share_config = { "common": { "bdSnsKey": {}, "bdText": "", "bdMini": "1", "bdMiniList": false, "bdPic": "", "bdStyle": "0", "bdSize": "16" }, "share": {} }; with (document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = '//csdnimg.cn/static/api/js/share.js?v=89860594'];</script>
<script type="text/javascript" >
    if($(".article_collect li").length==1){$(".article_collect").hide();}
    if($(".article_tags li").length==1){$(".article_tags").hide();}
    $(".edit a").attr("href","//mp.csdn.net/postedit/"+fileName);
    $.each($(".edu_li a"),function(){$(this).attr("href",$(this).attr("href").replace("blog7","blog9"))});
    new CNick('#uid').showNickname();

    if($("#fan").html()=="")
    {
	    $("#fan").html(0);
    }
</script>
<script src="//csdnimg.cn/public/common/append_mark/appendMark.min.js?v=5.00.43" type="text/javascript"></script>
<script type="text/javascript">
    appendMark($('.recommend_list').children('a').find('dt'),$('.extension_other'),$('.yd_a_d_feed_cla'))
</script>
<script src='//csdnimg.cn/pubfooter/js/publib_footer-1.0.3.js?v201802051726' data-isfootertrack="false"></script>
<script src='//csdnimg.cn/public/common/gotop/js/goTop-v1.0.min.js?v20180305174820'></script>
<script>
    GoTop({
        right: 8,
        hasReport: true,
        reportFun: function() {
            $.createMask();
            var r = blog_address + "/common/report?id=" + fileName + "&t=" + 2;
            if (3 == 2) {
                var s = n.parentNode.parentNode.parentNode.getAttribute("floor");
                r += "&floor=" + s
            }
            var i = (document.documentElement.clientHeight - 400) / 2 + (document.documentElement.scrollTop || document.body.scrollTop),
                a = (document.documentElement.clientWidth - 400) / 2;

            $("#report_dialog").load(r).css({
                //top: i + "px",
                top: '20%',
                left: a
            }).show()
        }
    })
</script>
<div id="loginWrap"></div>
<div id="dlMask"></div>
</body>
